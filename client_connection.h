

// ClientConnection represents a network connection made from an external
// client to the proxy.
class ClientConnection : public Connection {
public:
  // Client connections participate in a doubly-linked list in the Server object.
  ClientConnection * prev_connection, * next_connection;

  // MySQL capability flags for this connection (as requested by the client).
  uint32_t capability_flags;

  // For MySQL "Secure Password Authentication", this is the 20-byte random challenge string
  // generated by the proxy for this client connection (plus NUL terminator).
  // (http://dev.mysql.com/doc/internals/en/secure-password-authentication.html#packet-Authentication::Native41)
  uint8_t secure_auth_challenge[SHA1_DIGEST_LENGTH+1];

  // The database connection we are currently leasing, if any (otherwise null).
  DatabaseConnection * currently_leased_database_connection;

  // Whether the client has an active transaction open.  This is driven by the status
  // flags in OK or EOF packets.  Unfortunately, ERR packets in the MySQL protocol do not
  // contain status flags so this in_transaction flag may not be completely reliable.
  bool in_transaction;

  // If a database connection is currently being leased, this is the time at which it was acquired.
  time_t lease_acquired_at_time;

  // If a database connection is currently being leased, this is the time the last
  // query command was received from the client connection (including the initial query
  // that triggered the lease acquisition to begin with).
  time_t lease_last_activity_time;

  // Current pending lease request for this connection, if any.
  PendingLeaseRequest * pending_lease_request;

  // If this is true, the client connection is ready to accept and process the next packet
  // from the input buffer.  Otherwise, any incoming packets will be deferred in the
  // packet_data_queue list.
  bool ready_to_accept_input;

  // If this is true, once whatever is currently in this connection's write buffer
  // is finished being sent, this connection will be flagged for closing.
  bool close_when_output_finishes;

  // Pending raw packet data queue.  These represent packets that came in while
  // ready_to_accept_input was false.  Due to the quirks of the MySQL protocol, we don't
  // actually want to parse these into full Packet objects yet, until the client is ready
  // to handle them.  But we also don't want to just leave the data in the libevent input
  // buffer either.  Therefore, when data comes in for a client connection that is not ready
  // to handle it, the raw packets are appended to this queue for later processing.
  PacketDataWithLink * packet_data_queue_head, * packet_data_queue_tail;

  // Total number of bytes buffered into the packet_data_queue.
  size_t packet_data_queue_size;

  // Timing stats for the most recently executed query (if any).
  // The complete set here is only valid after the final query result
  // packet has been read from the database and is invalidated as soon
  // as the client sends us another query packet.
  // The total time a query took is query_finished - query_received_from_client.
  struct {
    // Time at which a client first has sent us a complete query packet.
    struct timeval query_received_from_client;

    // Time at which we were able to acquire a database lease for the query.
    struct timeval lease_acquired;

    // Time at which the first packet in response to the query has been read
    // from the database (i.e. the first resultset packet).
    struct timeval response_started_from_database;

    // Time at which all rows have been read and the query completed.
    struct timeval query_finished;
  } query_timings;
  
public:
  ClientConnection();
  virtual ~ClientConnection();

  void update_description();

  virtual void connection_established();
  virtual void remote_closed_connection();
  void close();
  void really_close();

  bool has_exceeded_lease_timeout() const;

  virtual void record_outgoing_network_traffic(size_t bytes);

  virtual void input_has_been_processed();
  virtual void record_incoming_network_traffic(size_t bytes);
  virtual void handle_received_packet_data(PacketData packet_data);

  void start_accepting_input();
  void stop_accepting_input();
  void append_packet_data_to_queue(PacketData data);

  virtual void write_buffer_is_empty();

  void send_initial_handshake_packet();
  void send_error_packet(const char * error_message, const char * sql_state_string,
                         int packet_sequence_number);
  void send_ok_packet(int packet_sequence_number);

  virtual void handle_resultset_header(PacketData packet_data) { handle_unexpected_packet_data(packet_data); }
  virtual void handle_resultset_field_description(PacketData packet_data)  { handle_unexpected_packet_data(packet_data); }
  virtual void handle_resultset_row(PacketData packet_data) { handle_unexpected_packet_data(packet_data); }
  virtual void handle_field_list_response(PacketData packet_data) { handle_unexpected_packet_data(packet_data); }

  virtual void generate_secure_auth_challenge();

  virtual void handle_handshake_v10_packet(HandshakeV10Packet * packet) {}
  virtual void handle_handshake_response_41_packet(HandshakeResponse41Packet * packet);
  virtual void handle_ok_packet(OKPacket * packet) {}
  virtual void handle_error_packet(ErrorPacket * packet) {}
  virtual void handle_eof_packet(EOFPacket * packet) {}
  virtual void handle_query_packet(QueryPacket * packet);
  virtual void handle_quit_packet(QuitPacket * packet);
  virtual void handle_init_db_packet(InitDBPacket * packet);
  virtual void handle_field_list_request_packet(FieldListRequestPacket * packet);
  virtual void handle_ping_packet(PingPacket * packet);
  virtual void handle_statistics_packet(StatisticsPacket * packet);
  virtual void handle_shutdown_packet(ShutdownPacket * packet);
  virtual void handle_refresh_packet(RefreshPacket * packet);
  virtual void handle_unsupported_packet(UnsupportedPacket * packet);

  bool check_client_authentication(const ConnectionPool * pool,
                                   const char * username,
                                   uint8_t secure_auth_challenge_response[SHA1_DIGEST_LENGTH+1]) const;
  bool select_schema(const char * schema_name,
                     const char * username,
                     uint8_t secure_auth_challenge_response[SHA1_DIGEST_LENGTH+1],
                     int packet_sequence_number);
  void start_database_query(Packet * packet, ConnectionState new_state,
                            ExpectedPacketType expected_packet_type);
  void record_query_timings();
};

